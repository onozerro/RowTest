<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Game</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; }
        canvas { display: block; }
        
        /* ===== TOP PANEL BLACK-WHITE ===== */
        #top-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
        }
        
        /* Black-white flat buttons */
        .top-btn {
            width: 46px;
            height: 46px;
            background: #333;
            border: 2px solid #666;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            transition: all 0.1s;
            position: relative;
        }
        
        .top-btn:hover {
            background: #444;
            border-color: #888;
        }
        
        .top-btn:active {
            background: #222;
            border-color: #555;
        }
        
        .btn-icon {
            width: 24px;
            height: 24px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            filter: grayscale(100%) brightness(1.5);
        }
        
        #menu-btn .btn-icon {
            background-image: url('https://cdn-icons-png.flaticon.com/512/56/56763.png');
        }
        
        #chat-btn .btn-icon {
            background-image: url('https://img.icons8.com/?size=100&id=VhoPIeUVX2mw&format=png&color=000000');
            filter: grayscale(100%) brightness(1.8);
            width: 26px;
            height: 26px;
        }
        
        /* ===== BLACK-WHITE MENU ===== */
        #game-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #222;
            padding: 20px;
            width: 280px;
            display: none;
            z-index: 1000;
            border-radius: 6px;
            border: 2px solid #555;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .menu-title {
            font-size: 20px;
            text-align: center;
            margin-bottom: 20px;
            color: white;
            padding-bottom: 10px;
            border-bottom: 1px solid #555;
        }
        
        .menu-btn {
            width: 100%;
            padding: 12px;
            margin: 6px 0;
            background: #444;
            border: 1px solid #666;
            color: white;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.1s;
        }
        
        .menu-btn:hover {
            background: #555;
            border-color: #777;
        }
        
        .menu-btn:active {
            background: #333;
        }
        
        #close-menu {
            background: #444;
            border-color: #666;
        }
        
        #close-menu:hover {
            background: #666;
        }
        
        /* ===== CHAT UNDER BUTTON ===== */
        #chat-container {
            position: absolute;
            top: 60px; /* Под кнопкой чата */
            left: 10px;
            width: 250px; /* Меньше размер */
            background: #222;
            display: none;
            z-index: 100;
            border-radius: 6px;
            border: 2px solid #555;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .chat-header {
            background: #333;
            padding: 8px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 4px 4px 0 0;
            border-bottom: 1px solid #555;
        }
        
        .chat-title {
            font-size: 13px;
            font-weight: bold;
            color: white;
        }
        
        .close-chat {
            background: #444;
            border: 1px solid #666;
            color: white;
            padding: 3px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 11px;
            transition: all 0.1s;
        }
        
        .close-chat:hover {
            background: #555;
        }
        
        .close-chat:active {
            background: #333;
        }
        
        .chat-messages {
            height: 160px; /* Меньше высота */
            overflow-y: auto;
            padding: 8px;
            font-size: 12px;
            background: #111;
            border: 1px solid #333;
            margin: 8px;
            border-radius: 4px;
            color: #ddd;
        }
        
        .chat-message {
            margin-bottom: 5px;
            padding: 3px;
            border-bottom: 1px solid #333;
            font-size: 11px;
        }
        
        .message-author {
            color: #aaa;
            font-weight: bold;
            font-size: 11px;
        }
        
        .chat-input {
            display: flex;
            padding: 8px;
            gap: 5px;
        }
        
        .chat-input input {
            flex: 1;
            padding: 6px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 11px;
            background: #111;
            color: white;
        }
        
        .chat-input button {
            padding: 6px 10px;
            background: #444;
            border: 1px solid #666;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 11px;
            transition: all 0.1s;
        }
        
        .chat-input button:hover {
            background: #555;
        }
        
        .chat-input button:active {
            background: #333;
        }
        
        /* ===== SPEECH BUBBLE ===== */
        #speech-bubble {
            position: absolute;
            background: #333;
            padding: 8px 12px;
            font-size: 12px;
            color: white;
            white-space: nowrap;
            z-index: 50;
            display: none;
            pointer-events: none;
            border-radius: 6px;
            border: 1px solid #555;
        }
        
        #speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: #333 transparent transparent;
        }
        
        /* ===== BLACK-WHITE MOBILE CONTROLS ===== */
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            justify-content: space-between;
            padding: 0 30px;
            pointer-events: none;
            display: none;
        }
        
        .joystick {
            width: 100px;
            height: 100px;
            background: rgba(30,30,30,0.8);
            border: 2px solid #666;
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
        }
        
        .joystick-handle {
            width: 50px;
            height: 50px;
            background: #444;
            border-radius: 50%;
            position: absolute;
            top: 25px;
            left: 25px;
            transition: transform 0.1s;
            border: 1px solid #666;
        }
        
        .jump-btn {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: #333;
            color: white;
            font-size: 40px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            border: 2px solid #666;
            transition: all 0.1s;
        }
        
        .jump-btn:active {
            background: #222;
        }
        
        #arrow-up {
            font-size: 40px;
            line-height: 1;
            color: #aaa;
        }
        
        /* ===== RESPONSIVE ===== */
        @media (min-width: 769px) {
            #mobile-controls { display: none !important; }
        }
        
        @media (max-width: 768px) {
            #mobile-controls { display: flex; }
            #chat-container {
                width: 220px;
                top: 65px;
                left: 5px;
            }
        }
    </style>
</head>
<body>
    <!-- Top Panel -->
    <div id="top-panel">
        <button class="top-btn" id="menu-btn" title="Menu">
            <div class="btn-icon"></div>
        </button>
        <button class="top-btn" id="chat-btn" title="Chat">
            <div class="btn-icon"></div>
        </button>
    </div>
    
    <!-- Menu -->
    <div id="game-menu">
        <div class="menu-title">MENU</div>
        <button class="menu-btn" onclick="resumeGame()">Continue</button>
        <button class="menu-btn" onclick="openSettings()">Settings</button>
        <button class="menu-btn" onclick="showHelp()">Help</button>
        <button class="menu-btn" id="close-menu" onclick="quitGame()">Quit</button>
    </div>
    
    <!-- Chat (под кнопкой) -->
    <div id="chat-container">
        <div class="chat-header">
            <div class="chat-title">CHAT</div>
            <button class="close-chat" onclick="toggleChat()">X</button>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="chat-message"><span class="message-author">System:</span> Welcome to the game!</div>
        </div>
        <div class="chat-input">
            <input type="text" id="chat-input" placeholder="Type a message..." maxlength="100">
            <button onclick="sendMessage()">OK</button>
        </div>
    </div>
    
    <!-- Speech Bubble -->
    <div id="speech-bubble"></div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div class="joystick" id="joystickBase">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
        <button class="jump-btn" id="jumpBtn">
            <div id="arrow-up">↑</div>
        </button>
    </div>
    
    <!-- Audio -->
    <audio id="jump-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-jump-arcade-game-166.mp3" type="audio/mpeg">
    </audio>
    <audio id="walk-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-footsteps-on-grass-503.mp3" type="audio/mpeg">
    </audio>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === CONFIGURATION ===
        let scene, camera, renderer;
        let playerGroup, parts = {};
        let platforms = [];
        let isMobile = /Mobi|Android/i.test(navigator.userAgent);
        
        // Controls
        const keys = { w: false, a: false, s: false, d: false };
        let cameraAngleX = 0, cameraAngleY = 0;
        let cameraDistance = 10;
        const minCameraDistance = 5;
        const maxCameraDistance = 20;
        let velocity = { x: 0, y: 0, z: 0 };
        let onGround = true;
        const gravity = 0.015;
        const jumpForce = 0.35;
        
        // Camera
        let isRightMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        const cameraSensitivity = 0.003;
        
        // Animation
        let animTarget = { legL: 0, legR: 0, armL: 0, armR: 0 };
        let animCurrent = { legL: 0, legR: 0, armL: 0, armR: 0 };
        let animSpeed = 0.2;
        let lastStepTime = 0;
        const stepInterval = 300;
        
        // Mobile controls
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };
        let initialPinchDistance = 0;
        
        // Textures
        let groundTexture = null;
        let textureLoaded = false;
        
        // Sounds
        let soundsEnabled = true;
        const jumpSound = document.getElementById('jump-sound');
        const walkSound = document.getElementById('walk-sound');
        
        // Chat
        let speechBubbleTimer = null;
        let chatOpen = false;
        
        // === INITIALIZATION ===
        init();
        
        function init() {
            // Scene with blue sky
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 200;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            
            scene.add(sunLight);
            
            // Load ground texture
            loadGroundTexture();
            
            // Create player
            createPlayer();
            
            // Setup controls
            setupControls();
            
            // Setup UI
            setupUI();
            
            // Mobile controls
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'flex';
            }
            
            // Start game
            animate();
            
            window.addEventListener('resize', onWindowResize);
        }
        
        function loadGroundTexture() {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.crossOrigin = "anonymous";
            
            // YOUR GREEN BLOCK TEXTURE
            textureLoader.load(
                'https://static.vecteezy.com/system/resources/previews/046/929/662/non_2x/green-plastic-toy-baseplate-background-with-grid-of-circular-studs-square-banner-backdrop-vector.jpg',
                function(texture) {
                    groundTexture = texture;
                    groundTexture.wrapS = THREE.RepeatWrapping;
                    groundTexture.wrapT = THREE.RepeatWrapping;
                    groundTexture.repeat.set(20, 20);
                    textureLoaded = true;
                    createWorld();
                },
                undefined,
                function(err) {
                    console.log('Texture loading error, using color');
                    textureLoaded = true;
                    createWorld();
                }
            );
        }
        
        function createWorld() {
            // GROUND WITH YOUR TEXTURE
            const groundGeometry = new THREE.BoxGeometry(300, 2, 300);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00aa00,
                map: groundTexture || null
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.y = 1;
            ground.receiveShadow = true;
            ground.castShadow = true;
            scene.add(ground);
            
            // Collisions
            ground.userData = {
                width: 300,
                height: 2,
                depth: 300,
                top: 2,
                bottom: 0,
                position: ground.position
            };
            platforms.push(ground);
            
            // Player
            playerGroup.position.set(0, 4, 0);
            onGround = true;
        }
        
        function createPlayer() {
            playerGroup = new THREE.Group();
            
            const skin = new THREE.MeshLambertMaterial({ color: 0xffcd38 });
            const shirt = new THREE.MeshLambertMaterial({ color: 0x3366cc });
            const pants = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            
            // Body
            const torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), shirt);
            torsoMesh.position.y = 1;
            torsoMesh.castShadow = true;
            playerGroup.add(torsoMesh);
            
            // Head
            const headMesh = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), skin);
            headMesh.position.y = 2.6;
            headMesh.castShadow = true;
            playerGroup.add(headMesh);
            
            // Body parts
            const createPart = (w, h, d, mat, y, name) => {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true;
                const group = new THREE.Group();
                group.position.y = y;
                mesh.position.y = -h / 2;
                group.add(mesh);
                parts[name] = group;
                return group;
            };
            
            const armL = createPart(1, 2, 1, skin, 2, 'armL');
            armL.position.x = -1.5;
            const armR = createPart(1, 2, 1, skin, 2, 'armR');
            armR.position.x = 1.5;
            const legL = createPart(1, 2, 1, pants, 0, 'legL');
            legL.position.x = -0.5;
            const legR = createPart(1, 2, 1, pants, 0, 'legR');
            legR.position.x = 0.5;
            
            playerGroup.add(armL, armR, legL, legR);
            playerGroup.castShadow = true;
            scene.add(playerGroup);
        }
        
        // === PHYSICS ===
        function updatePhysics() {
            if (!textureLoaded) return;
            
            velocity.y -= gravity;
            playerGroup.position.y += velocity.y;
            
            checkPlatformCollision();
            
            if (playerGroup.position.y < -20) {
                respawn();
            }
        }
        
        function checkPlatformCollision() {
            onGround = false;
            const playerPos = playerGroup.position;
            const playerRadius = 0.8;
            const playerHeight = 4;
            const playerBottom = playerPos.y - playerHeight / 2;
            
            for (let platform of platforms) {
                const data = platform.userData;
                const platformPos = platform.position;
                
                const dx = Math.abs(playerPos.x - platformPos.x);
                const dz = Math.abs(playerPos.z - platformPos.z);
                
                if (dx < (data.width / 2 + playerRadius) && dz < (data.depth / 2 + playerRadius)) {
                    if (playerBottom <= data.top + 0.1 && playerBottom >= data.top - 0.5 && velocity.y <= 0) {
                        onGround = true;
                        velocity.y = 0;
                        playerGroup.position.y = data.top + playerHeight / 2;
                        break;
                    }
                }
            }
        }
        
        function updateMovement() {
            if (!textureLoaded) return;
            
            let move = false;
            const speed = 0.15;
            let dx = 0, dz = 0;
            
            if (keys.w) { dx += Math.sin(cameraAngleX); dz += Math.cos(cameraAngleX); move = true; }
            if (keys.s) { dx -= Math.sin(cameraAngleX); dz -= Math.cos(cameraAngleX); move = true; }
            if (keys.a) { dx += Math.sin(cameraAngleX + Math.PI/2); dz += Math.cos(cameraAngleX + Math.PI/2); move = true; }
            if (keys.d) { dx += Math.sin(cameraAngleX - Math.PI/2); dz += Math.cos(cameraAngleX - Math.PI/2); move = true; }
            
            if (joystickActive && isMobile) {
                dx += joystickVector.x;
                dz += joystickVector.y;
                if (Math.abs(joystickVector.x) > 0.1 || Math.abs(joystickVector.y) > 0.1) {
                    move = true;
                }
            }
            
            if (move) {
                const length = Math.sqrt(dx * dx + dz * dz);
                if (length > 0) {
                    dx = (dx / length) * speed;
                    dz = (dz / length) * speed;
                }
                
                playerGroup.position.x -= dx;
                playerGroup.position.z -= dz;
                playerGroup.rotation.y = Math.atan2(-dx, -dz);
                
                if (onGround && Date.now() - lastStepTime > stepInterval) {
                    playWalkSound();
                    lastStepTime = Date.now();
                }
            }
            
            updateAnimation(move);
        }
        
        function updateAnimation(isMoving) {
            if (!onGround) {
                animTarget = { legL: -0.2, legR: 0.2, armL: 3.14, armR: 3.14 };
            } else if (isMoving) {
                const t = Date.now() * 0.01;
                animTarget = { 
                    legL: Math.sin(t), legR: -Math.sin(t), 
                    armL: -Math.sin(t), armR: Math.sin(t) 
                };
            } else {
                animTarget = { legL: 0, legR: 0, armL: 0, armR: 0 };
            }
            
            const lerp = (start, end, amt) => (1 - amt) * start + amt * end;
            
            animCurrent.legL = lerp(animCurrent.legL, animTarget.legL, animSpeed);
            animCurrent.legR = lerp(animCurrent.legR, animTarget.legR, animSpeed);
            animCurrent.armL = lerp(animCurrent.armL, animTarget.armL, animSpeed);
            animCurrent.armR = lerp(animCurrent.armR, animTarget.armR, animSpeed);
            
            if (parts.legL) parts.legL.rotation.x = animCurrent.legL;
            if (parts.legR) parts.legR.rotation.x = animCurrent.legR;
            if (parts.armL) parts.armL.rotation.x = animCurrent.armL;
            if (parts.armR) parts.armR.rotation.x = animCurrent.armR;
        }
        
        function updateCamera() {
            if (!textureLoaded) return;
            
            const heightOffset = 4;
            camera.position.x = playerGroup.position.x + Math.sin(cameraAngleX) * cameraDistance * Math.cos(cameraAngleY);
            camera.position.z = playerGroup.position.z + Math.cos(cameraAngleX) * cameraDistance * Math.cos(cameraAngleY);
            camera.position.y = playerGroup.position.y + heightOffset + Math.sin(cameraAngleY) * cameraDistance;
            
            camera.lookAt(
                playerGroup.position.x,
                playerGroup.position.y + 2,
                playerGroup.position.z
            );
            
            updateSpeechBubble();
        }
        
        function updateSpeechBubble() {
            const bubble = document.getElementById('speech-bubble');
            if (bubble.style.display === 'block') {
                const playerPos = new THREE.Vector3(
                    playerGroup.position.x,
                    playerGroup.position.y + 4,
                    playerGroup.position.z
                );
                
                playerPos.project(camera);
                
                const x = (playerPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-playerPos.y * 0.5 + 0.5) * window.innerHeight;
                
                bubble.style.left = (x - bubble.offsetWidth / 2) + 'px';
                bubble.style.top = (y - 50) + 'px';
            }
        }
        
        function respawn() {
            playerGroup.position.set(0, 4, 0);
            velocity = { x: 0, y: 0, z: 0 };
            onGround = true;
        }
        
        // === CONTROLS ===
        function setupControls() {
            document.addEventListener('keydown', e => {
                if (e.code === 'KeyW') keys.w = true;
                if (e.code === 'KeyS') keys.s = true;
                if (e.code === 'KeyA') keys.a = true;
                if (e.code === 'KeyD') keys.d = true;
                if (e.code === 'Space' && onGround) {
                    velocity.y = jumpForce;
                    playJumpSound();
                }
                if (e.code === 'Enter') {
                    if (document.getElementById('chat-input') !== document.activeElement) {
                        toggleChat();
                        if (document.getElementById('chat-container').style.display === 'block') {
                            document.getElementById('chat-input').focus();
                        }
                    }
                }
            });
            
            document.addEventListener('keyup', e => {
                if (e.code === 'KeyW') keys.w = false;
                if (e.code === 'KeyS') keys.s = false;
                if (e.code === 'KeyA') keys.a = false;
                if (e.code === 'KeyD') keys.d = false;
            });
            
            document.addEventListener('wheel', e => {
                if (!isMobile) {
                    e.preventDefault();
                    cameraDistance += e.deltaY * 0.01;
                    cameraDistance = Math.max(minCameraDistance, Math.min(maxCameraDistance, cameraDistance));
                }
            }, { passive: false });
            
            if (!isMobile) {
                document.addEventListener('mousedown', e => {
                    if (e.button === 2) {
                        isRightMouseDown = true;
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        document.body.style.cursor = 'none';
                    }
                });
                
                document.addEventListener('mouseup', e => {
                    if (e.button === 2) {
                        isRightMouseDown = false;
                        document.body.style.cursor = 'default';
                    }
                });
                
                document.addEventListener('mousemove', e => {
                    if (isRightMouseDown) {
                        const deltaX = e.clientX - lastMouseX;
                        const deltaY = e.clientY - lastMouseY;
                        
                        cameraAngleX -= deltaX * cameraSensitivity;
                        cameraAngleY += deltaY * cameraSensitivity;
                        cameraAngleY = Math.max(-Math.PI/2, Math.min(Math.PI/3, cameraAngleY));
                        
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                    }
                });
                
                document.addEventListener('contextmenu', e => e.preventDefault());
            }
            
            if (isMobile) {
                setupMobileControls();
            }
        }
        
        function setupMobileControls() {
            const joystickBase = document.getElementById('joystickBase');
            const joystickHandle = document.getElementById('joystickHandle');
            const jumpBtn = document.getElementById('jumpBtn');
            
            let touchId = null;
            const maxDistance = 40;
            
            joystickBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchId = touch.identifier;
                joystickActive = true;
            }, { passive: false });
            
            joystickBase.addEventListener('touchmove', (e) => {
                if (!touchId) return;
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    if (touch.identifier === touchId) {
                        const rect = joystickBase.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        
                        let deltaX = touch.clientX - centerX;
                        let deltaY = touch.clientY - centerY;
                        
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        if (distance > maxDistance) {
                            deltaX = (deltaX / distance) * maxDistance;
                            deltaY = (deltaY / distance) * maxDistance;
                        }
                        
                        joystickVector.x = deltaX / maxDistance;
                        joystickVector.y = deltaY / maxDistance;
                        
                        joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        break;
                    }
                }
            }, { passive: false });
            
            joystickBase.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === touchId) {
                        joystickActive = false;
                        joystickVector = { x: 0, y: 0 };
                        joystickHandle.style.transform = 'translate(0, 0)';
                        touchId = null;
                        break;
                    }
                }
            });
            
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (onGround) {
                    velocity.y = jumpForce;
                    playJumpSound();
                    jumpBtn.style.background = '#222';
                }
            }, { passive: false });
            
            jumpBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                jumpBtn.style.background = '#333';
            }, { passive: false });
            
            // Camera control on mobile
            let cameraTouchId1 = null;
            let cameraTouchId2 = null;
            
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    cameraTouchId1 = e.touches[0].identifier;
                    cameraTouchId2 = e.touches[1].identifier;
                    initialPinchDistance = getTouchDistance(e.touches[0], e.touches[1]);
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                if (cameraTouchId1 !== null && cameraTouchId2 !== null && e.touches.length === 2) {
                    let touch1 = null, touch2 = null;
                    
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === cameraTouchId1) touch1 = e.touches[i];
                        if (e.touches[i].identifier === cameraTouchId2) touch2 = e.touches[i];
                    }
                    
                    if (touch1 && touch2) {
                        const currentDistance = getTouchDistance(touch1, touch2);
                        const delta = (initialPinchDistance - currentDistance) * 0.01;
                        
                        cameraDistance += delta;
                        cameraDistance = Math.max(minCameraDistance, Math.min(maxCameraDistance, cameraDistance));
                        initialPinchDistance = currentDistance;
                    }
                }
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === cameraTouchId1) cameraTouchId1 = null;
                    if (touch.identifier === cameraTouchId2) cameraTouchId2 = null;
                }
            });
            
            function getTouchDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        // === UI ===
        function setupUI() {
            document.getElementById('menu-btn').addEventListener('click', toggleMenu);
            document.getElementById('chat-btn').addEventListener('click', toggleChat);
            document.getElementById('chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        }
        
        function toggleMenu() {
            const menu = document.getElementById('game-menu');
            if (menu.style.display === 'block') {
                menu.style.display = 'none';
            } else {
                menu.style.display = 'block';
                // Закрываем чат если открыт
                if (chatOpen) {
                    document.getElementById('chat-container').style.display = 'none';
                    chatOpen = false;
                }
            }
        }
        
        function toggleChat() {
            const chat = document.getElementById('chat-container');
            if (chatOpen) {
                // Закрыть чат
                chat.style.display = 'none';
                chatOpen = false;
            } else {
                // Открыть чат под кнопкой
                chat.style.display = 'block';
                chatOpen = true;
                document.getElementById('chat-input').focus();
                // Закрываем меню если открыто
                document.getElementById('game-menu').style.display = 'none';
            }
        }
        
        function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            
            if (message) {
                addChatMessage('Player', message);
                showSpeechBubble(message);
                input.value = '';
            }
        }
        
        function addChatMessage(author, text) {
            const chatMessages = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            messageDiv.innerHTML = `<span class="message-author">${author}:</span> ${text}`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function showSpeechBubble(text) {
            const bubble = document.getElementById('speech-bubble');
            bubble.textContent = text;
            bubble.style.display = 'block';
            
            if (speechBubbleTimer) {
                clearTimeout(speechBubbleTimer);
            }
            speechBubbleTimer = setTimeout(() => {
                bubble.style.display = 'none';
            }, 5000);
        }
        
        // === SOUNDS ===
        function playJumpSound() {
            if (soundsEnabled) {
                jumpSound.currentTime = 0;
                jumpSound.play().catch(e => console.log("Sound error"));
            }
        }
        
        function playWalkSound() {
            if (soundsEnabled) {
                walkSound.currentTime = 0;
                walkSound.play().catch(e => console.log("Sound error"));
            }
        }
        
        // === MENU ===
        function resumeGame() {
            document.getElementById('game-menu').style.display = 'none';
        }
        
        function openSettings() {
            alert('SETTINGS\n\nSound: ' + (soundsEnabled ? 'ON' : 'OFF') + '\nControls: ' + (isMobile ? 'TOUCH' : 'KEYBOARD/MOUSE') + '\n\nControls:\nWASD - movement\nSpace - jump\nRMB - rotate camera\nMouse wheel - zoom');
        }
        
        function showHelp() {
            alert('HELP\n\nMove on the green area\nUse chat to communicate\nPress Enter to open chat');
        }
        
        function quitGame() {
            if (confirm('Quit game?')) {
                window.close();
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // === MAIN LOOP ===
        function animate() {
            requestAnimationFrame(animate);
            
            if (textureLoaded) {
                updatePhysics();
                updateMovement();
                updateCamera();
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>